\documentclass[11pt, journal, twocolumn, twoside]{IEEEtran}

\usepackage{url}
\usepackage{graphicx}
\usepackage{framed}
\usepackage{listings}
\RequirePackage{epsfig}
\RequirePackage{color}

\lstset{breaklines=true} 

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
\title{Stackable~File~System~Using~NFS~Ganesha}

\author{Arun~Olappamanna~Vasudevan,~\IEEEmembership{CS,~Stony~Brook~University,}
\thanks{Arun O. V. is a graduate student with the Department
of Computer Science, Stony Brook University, Stony Brook,
NY, 11079 USA e-mail: aolappamanna@cs.stonybrook.edu,
web: http://www.fsl.cs.sunysb.edu/\~{}arunov/}}% <-this % stops a space

% The paper headers
\markboth{Stackable~File~system~Using~NFS~Ganesha}%
{File~Systems~and~Storage~Lab}

\maketitle

\begin{abstract}
%\boldmath
NFS Ganesha is a userland implementation of Network File System. This article
explores stackable file system feature supported by NFS Ganesha version 2.0.
A file-encrypting stackable file system CRYPTFS.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
network file system, file system, file system abstraction layer, proxy,
NFSv4, NFS, FSAL, stackable
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}
\IEEEPARstart{G}{anesha} NFS being a userland implementation of Network File
System protocol is a convenient place to try out new features and algorithms.
Duo Yi and Youlong Cheng implemented security features in proxy server
\cite{NFSv4SecurityProxy} using Ganesha NFS. The implementation is mostly in
NFSv4 protocol, which makes it highly inflexible and non-modular. Stackable
FSAL might help implement features in a cleaner way.

Stackable FSAL was explored by implementing a basic file-encrypting
stackable file system in NFS Ganesha version 2.0.

\section{Project Design}
In order to design stackable file system in NFS Ganesha, an overview of NFS
Ganesha is discussed first.

\subsection{FSAL - File System Abstraction Layer}
There are several types of file systems supported by Ganesha. The FSAL is an
abstraction layer that abstracts each file system to a set of common operations
that are handled by each module.

Each module can be configured using special key-value pairs in
configuration file that is parsed by NFS Ganesha. For instance, FSAL\_PROXY
required Srv\_Addr to be defined in configuration file.

\subsubsection{PROXY FSAL}
This is an abstraction that implements proxy machine between a client and a
server. FSAL\_PROXY uses NFSv4. Figure \ref{fsalProxyArch} shows how requests
from clients are handled by FSAL\_PROXY by contacting server.

\begin{figure*}[!btp]
  \centering
  \psfig{figure=figs/ganesha-proxy-overview.eps, width=\textwidth}
  \caption{Architecture of FSAL\_PROXY}
  \label{fsalProxyArch}
\end{figure*}

\begin{enumerate}
\item Init module invokes config parser %1
\item `proxy.ganesha.conf' is parsed %2
\item Library mentioned as value of `FSAL\_Shared\_Library' is loaded %3
\item dlopen() invokes constructor that registers FSAL of library %4
\item FSAL added to fsal\_list, call backs registered for configuration (init\_config) and creating export (create\_export) %5
\item EXPORT block in config file corresponds to a line in /etc/exports in Linux. Export entry is created with the FSAL
mentioned in EXPORT block. In this case PROXY. %6
\item Proxy operations are registered with the export entry (function pointers for read, write, open, close, etc.) %7
\item After config file is parsed, all FSALs in fsal\_list are initialized %8
\item Initialization of FSAL Proxy %9
\item Configuration items specific to FSAL Proxy, such as server address (Srv\_addr) is obtained from config parse tree %10
\item Thread spawned to connect to server and initialize RPC %11
\item RPC socket that's used for send RPC request and listen %12
\item Worker threads spawned for handling requests from client %13
\item NFSv4 request from client received by worker thread %14
\item After access permission (supports even authentication) checks of client on export entry corresponding to request, NFSv4 service function (usually nfs4\_Compound) is called %15
\item All metadata is maintained in cache inode and dentry data structures in AVL trees. Request received from NFSv4 operations. %16
\item Request is forwarded to FSAL operations registered to particular export entry %17
\item Server request through RPC socket %18
\item NFSv4 request to Server %19
\item NFSv4 response from Server %20
\item Response passed to PROXY handler %21
\item Response passed to cache inode %22
\item Response passed to NFSv4 protocol handler %23
\item Response passed to worker thread %24
\item svc\_sendreply() to client %25
\end{enumerate}

\subsubsection{Stackable FSAL}
Every EXPORT block in config file has a FS\_Specific entry that is passed to create\_export()
function of FSAL of the export entry. The FS\_Specific entry is again an FSAL name. This
opens possibilities for using the FS\_Specific for stacking on top of a particular FSAL.
Figure \ref{fsalStackArch} shows architecture and working of a  general stackable FSAL.

\begin{figure}[!btp]
  \centering
  \psfig{figure=figs/ganesha-stackable-fsal.eps, width=0.5\textwidth}
  \caption{Architecture of Stackable FSAL}
  \label{fsalStackArch}
\end{figure}

\section*{Acknowledgment}
Ming Chen has been extremely supportive through the duration of work on NFS Ganesha and Stackable FS.

\bibliographystyle{IEEEtran}
\bibliography{ganesha-stackable-nfs-overview}

\end{document}

